* Rename the implementation classes.
* Add doxygen comments for the APIs?
* Change fake/eiger backends to immediate/delayed (meaning: to file, or to mem and file afterwards)
* Use macro voodoo to turn EIGER_MODEL stuff into gotos, rather than if(0) calls. --> Probably bad, breaks return address stack
* Consider implementing everything in C++ with templates (which are pretty much
macros anyway), and exposing a C/fortran API as necessary.
* What would make this thread-safe?
    The actual measurement count is done per thread (or process??).
    A new data point is made per thread (ie each entry to the backend is independent)
        This would require a mutex around the backend (require c++11? that's probably ok)
* Runtime warning after execution if a start doesn't enter a matching stop


template<typename T, typename... Targs>
void parse(T value, Targs... rest){
    add(value);
}

template<typename T>
add(T value);

template<>
add<datakind::RESULT>(datakind::RESULT value);


Add in timer so we can handle overflow.
    Necessary? Are any compute regions greater than ~60 secs?
    Would need to set up and tear down per region. Maybe just print out a
    warning if the end time is greater than some threshold, indicating that it
    should be re-run with overflow handling turned on.
        Add a compilation flag that turns on overflow handling.
